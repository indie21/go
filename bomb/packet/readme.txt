本模块提供几种网络序列化方式

1.json
2.bz二进制(bz是我随便打的字母)
3.或者更多。。。

你可在程序种像插件一样选择这些序列化方式，和agent组合成服务器功能。


裸包:Packet:管理2进制

逻辑包:
所有逻辑包都需要实现对裸包的Pack和Unpack.

或许可以把裸包去掉，直接用Reader和Writer.??
不知道性能会不会好。


所有的packet类型都需要实现对Packet的转换关系。

PacketBz  ->  packet(2进制包)
PacketBz  <-  packet(2进制包)


一种网络数据序列化的方式.

每一个数据包都由三部分组成： 包长度(2字节)+包类型(2字节)+包数据(剩余字节)。
每个正常包的前两个字节都是包长，也就是你必须先收两个字节，确定之后的包的长度，等待完整包收完后再处理。

1.包类型为2个字节，最多有65535个不同的包，完全够用了。

一个完整的包收好后，将通过包类型来决定如何处理，包类型的描述我定义在了proto/api.txt文件中，每个包有以下5个属性需要配置:

1.packet_type:包类型，必须是一个唯一的正数
2.name:包名字，毕竟数字在代码里不是很友好
3.payload:包内容，这说明包类型确定后，包内容也确定了
4.desc:一句注释而已.
5.module:请求处理模块，只对以_req为后缀的包名字的包有用，可以直接映射到处理模块。

2.包内容

数据包的内容我称其为payload，他们全部在proto/protocal.txt中被定义，包内容定义比较复杂，以下是基础类型，你可以通过基础类型组合成自定义类型：

integer：数字类型
float:浮点类型
string:字符串类型，实际上处理为erlang的binary类型
boolean：布尔类型，只占1个字节
short：端整型

有了基本类型，你可以自定义一个用户类型：

pt_user=
name string
sex boolean
===
非常简单，你可以定义一个账号类型，它嵌套了用户类型:

pt_account=
user pt_user
money integer
===
很多情况下我们需要数组，你可以这样定义一个含有数组的类型：


用户累类型可以组合成新的用户类型
account_i=
pt pt_account
cls integer
===
